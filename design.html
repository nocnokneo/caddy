<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Caddy: Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Caddy
   </div>
   <div id="projectbrief">A 2005 Roborodentia entry with vision and path planning capability</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Design </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="team_process"></a>
Collaborative Team Process</h1>
<h1><a class="anchor" id="collaborative_tools"></a>
Collaborative Tools</h1>
<p>The team for this project was formed from interested members of the the <a href="http://robotics.ee.calpoly.edu/">Cal Poly Robotics Club</a>.</p>
<p>To organize the tasks and identify critical paths in the (short) project time line, we used <a href="http://www.ganttproject.biz/">GanttProject</a> to create a Gantt chart.</p>
<p>For code control and collaboration we used Concurrent Versions System (CVS). Since this project had a competitive nature, we chose to setup and host our own private CVS server over some of the free CVS hosting services found on the internet.</p>
<p>Between face-to-face team meetings we used Drupal to host a private forum for discussing ideas, sharing progress, etc.</p>
<p>Inline code documentation as well as this project report were managed using <a href="http://doxygen.org">Doxygen</a>. Keeping the documentation in plain text and means that the documentation can be version controlled the very same way as the source code. The documentation also tends to stay more up to date since it is "close to the code".</p>
<h1><a class="anchor" id="system_arch"></a>
System Architecture</h1>
<p>Info about system architecture</p>
<h1><a class="anchor" id="electrical_design"></a>
Electrical Design</h1>
<h2><a class="anchor" id="power_motor"></a>
Power Regulation and Motor Controller</h2>
<p>Resolving software bugs and electrical noise issues at the same time is almost impossible, so we wanted to build a reliable power supply board to provide clean regulated power to the electronics, free of all the back EMF generated by the DC motors. We came up with a simple design to provide</p>
<ul>
<li>Raw, unregulated battery voltage for the motors via an H-bridge driver </li>
<li>Decoupled, unregulated power for the CMUcam </li>
<li>Decoupled, regulated power for the rest of the electronics</li>
</ul>
<p>Using unregulated batter power to drive the motors meant we could save on the cost of an expensive voltage capable of driving the relatively high power demands of the DC motors.</p>
<p>We made sure to use polarized headers for all the connections because at 5 in the morning after a long coding session you are liable to make all kinds of stupid blunders. Even with prevention measures like this, we made a few.</p>
<h2><a class="anchor" id="ir_break_beam"></a>
IR Break Beam</h2>
<p>To detect when a ball is within the grasp of the lift we had two options. Originally we thought that we could simply use the centroid tracking feature of the camera since we would have the camera facing down watching the line anyway. This turned out to be difficult for a couple reasons.</p>
<p>When the camera is configured to track a black line, glare from the overhead lighting and red golf balls have the same effect on what the camera sees – a gap in the line. This seemed like an easily surmountable problem at first. Just change modes whenever a gap is detected, determine if it is a ball or a glare, and act accordingly. As with any software program, introducing one seemingly small change has the potential to severely affect the rest of the system. This particular case was no exception. First, the CMUcam did not handle rapid mode/parameter changes well, taking longer than we expected to go from one mode to another. This lead to a failure in our finely tuned PID line tracking algorithm which relied on frequent, regular updates over time. We considered and experimented with some ways of solving this problem but none were the quick, elegant solution we were looking for.</p>
<p>With a fast approaching deadline and still much to do, we decided that the quickest way to solve the problem was to simply setup a break beam sensor in just the right position to detect when the lift mechanism should be raised. This was fast to implement and worked reliably.</p>
<p>Here is a schematic of our break beam circuit:</p>
<h2><a class="anchor" id="servo_reverser"></a>
Servo Reverser</h2>
<p>The mechanical design of Caddy required 6 servos:</p>
<ul>
<li>Ball pickup, left side </li>
<li>Ball pickup, right side </li>
<li>Boom control </li>
<li>Ball hopper </li>
<li>Tilt action </li>
<li>Pan action</li>
</ul>
<p>This meant that the original plan to use the five servo control outputs of the CMUcam would be inadequate.</p>
<p>The following approaches were considered for accommodating the 6th servo output:</p>
<ul>
<li><b>Mechanical:</b> Modify the mechanical design so that the ball pickup mechanism could be controlled by just one high-torque servo. Tyson had already done such an awesome job of designing the lift to be actuated by just one mechanical motion that this seemed like too much to ask.</li>
</ul>
<ul>
<li><b>Software:</b> Use some of the extra pins on the ATmega32 to generate a servo PWM signal. Unfortunately we were already using the two PWM peripherals on the ATmega32 so we would have to do this in software. We had limited timer resources on our chip and weren't sure how we might need to use them in the future so this was not an ideal solution.</li>
</ul>
<ul>
<li><b>Electrical:</b> Leverage the fact that the 2 servos controlling the ball pickup were the same signal, 180 degrees out of phase. This seemed like a perfect application for a simple 555 timer circuit.</li>
</ul>
<p>We decided to use the 555 timer approach. Using plans found online, we fabricated the board with a 4-pin header so that the circuit could easily be reused in the future.</p>
<h2><a class="anchor" id="wheel_encoders"></a>
Wheel Encoders</h2>
<p>The maneuvers needed at junctions and for the bonus ball pick up sequences needed to be accurate and repeatable. To achieve this we used a black and white encoder disk that we printed out and glued to the inside edge of each drive wheel.<a class="el" href="citelist.html#CITEREF_walters_dead_reckoning_2000">[1]</a></p>
<div class="image">
<img src="encoder_disc.png" alt="encoder_disc.png"/>
<div class="caption">
Reflective IR wheel encoder pattern</div></div>
<h1><a class="anchor" id="software_architecture"></a>
Software Architecture</h1>
<h2><a class="anchor" id="computing_platform"></a>
Computing Platform</h2>
<p>For our our computing platform we chose an ATmega32 microcontroller from Atmel's 8-bit AVR line of microcontrollers because it was C-programmable with free open-source tools and because we had a readily available development board, the ERE EMBMega32.</p>
<div class="image">
<img src="ere_embmega32.png" alt="ere_embmega32.png"/>
<div class="caption">
EMBMega32 development board from ERE CO.,LTD</div></div>
<h2><a class="anchor" id="line_tracking"></a>
PID Line Tracking</h2>
<p>To track the black electrical tape line, we implemented a proportional–integral–derivative (PID) controller. In PID theory, the output of a PID controller, <img class="formulaInl" alt="$c(t)$" src="form_0.png"/>, is defined as:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ c(t) = P_E e(t) + P_I \int e(t) dt + \P_0 \frac{de}{dt} \]" src="form_1.png"/>
</p>
<p>Where <img class="formulaInl" alt="$ e(t) $" src="form_2.png"/> is some error function and <img class="formulaInl" alt="$ P_E $" src="form_3.png"/>, <img class="formulaInl" alt="$ P_I $" src="form_4.png"/>, and <img class="formulaInl" alt="$ P_D $" src="form_5.png"/> are adjustment coefficients for the observed error, the integrated error and the derivative of the error, respectively.</p>
<div class="image">
<img src="line_tracking.png" alt="line_tracking.png"/>
<div class="caption">
Diagram of line tracking geometry</div></div>
<h2><a class="anchor" id="maneuvering"></a>
Maneuvering</h2>
<p>When turning our bot by a certain number of ticks, we experienced overshoot despite actively applying DC motor braking. We addressed the problem with the following software solution.</p>
<p>After turning for the desired number of ticks, we applied braking and counted the number of excess ticks that occurred from the instant braking was commanded. After a fixed delay, we drove the wheels in the opposite direction for that same number of ticks.</p>
<p>This worked well for the most part, however, with different battery charges, turn amounts, and turn types, the amount of time to brake was never the same. If we did not brake the motors for a long enough delay, our bot would stop counting excess ticks and begin to drive the motors in the opposite direction, too soon. With our unsophisticated encoders that cannot detect the direction of wheel motion this resulted in a "reverse ticks" being counted before the wheel had actually started moving in the reverse direction.</p>
<h2><a class="anchor" id="ball_detection"></a>
Ball Detection and Localization</h2>
<h2><a class="anchor" id="path_planning"></a>
Path Planning</h2>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Feb 24 2013 13:31:11 for Caddy by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
